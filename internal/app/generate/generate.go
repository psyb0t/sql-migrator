package generate

import (
	"fmt"
	"os"
	"path"
	"regexp"
	"sort"
	"strconv"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
)

const (
	firstNumber = "0000000001"
	fileFmt     = "%s_%s.%s"
	fileExtUp   = "up.sql"
	fileExtDown = "down.sql"
)

//nolint:gochecknoglobals
var generateFlags struct {
	dirPath string
	name    string
}

func HandleFlags(cmd *cobra.Command) {
	var name, value, usage string

	name = "dir"
	value = ""
	usage = "Path to migrations directory"
	cmd.Flags().StringVar(&generateFlags.dirPath, name, value, usage)

	name = "name"
	value = ""
	usage = "Name of the migration"
	cmd.Flags().StringVar(&generateFlags.name, name, value, usage)
}

func validateFlags() {
	logrus.Debug("entered validateGenerateFlags function")

	if generateFlags.dirPath == "" {
		logrus.Fatalf("migrations directory path cannot be empty")
	}

	if generateFlags.name == "" {
		logrus.Fatalf("migration name cannot be empty")
	}
}

func Run(_ *cobra.Command, _ []string) {
	logrus.Debug("started generate")

	validateFlags()

	logrus.Infof("dir: %s, name: %s", generateFlags.dirPath, generateFlags.name)

	logrus.Debug("getting next migration number")

	nextNum := getnextNum(generateFlags.dirPath)

	logrus.Infof("next migration number: %s", nextNum)

	createMigrationFiles(generateFlags.dirPath, nextNum, generateFlags.name)
}

func createMigrationFiles(dirPath, number, name string) {
	logrus.Debugf(
		"entered createMigrationFiles function number: %s name: %s",
		number,
		name,
	)

	logrus.Debugf("ensure migrations directory exists: %s", dirPath)

	if _, err := os.Stat(dirPath); os.IsNotExist(err) {
		logrus.Debugf("migrations directory does not exist, creating: %s", dirPath)

		err = os.MkdirAll(dirPath, os.ModePerm)
		if err != nil {
			logrus.Fatal(err)
		}
	}

	upMigrationFileName := fmt.Sprintf(
		fileFmt,
		number,
		name,
		fileExtUp,
	)

	upMigrationFilePath := path.Join(dirPath, upMigrationFileName)
	logrus.Debugf("Creating migration file up: %s", upMigrationFilePath)

	createMigrationFile(upMigrationFilePath)

	downMigrationFileName := fmt.Sprintf(
		fileFmt,
		number,
		name,
		fileExtDown,
	)

	downMigrationFilePath := path.Join(dirPath, downMigrationFileName)
	logrus.Debugf("Creating migration file down: %s", downMigrationFilePath)

	createMigrationFile(downMigrationFilePath)
}

func createMigrationFile(filename string) {
	file, err := os.Create(filename)
	if err != nil {
		logrus.Fatal(errors.Wrapf(err, "failed to create file: %s", filename))
	}

	defer func() {
		logrus.Debugf("closing file: %s", filename)

		if err := file.Close(); err != nil {
			logrus.Fatalf("failed to close file: %v", err)
		}
	}()

	comment := fmt.Sprintf("-- This file (%s) was generated by the migrator\n", filename)
	if _, err = file.WriteString(comment); err != nil {
		logrus.Fatal(errors.Wrapf(err, "failed to write to file: %s", filename))
	}
}

func getnextNum(dirPath string) string {
	logrus.Debugf("entered getnextNum function dirPath: %s", dirPath)

	logrus.Debugf("Reading migrations directory: %s", dirPath)

	files := getFilesFromDir(dirPath)

	logrus.Debugf("Extracting migration numbers from %d files %v", len(files), files)

	numbers, maxLength := extractnumbers(files)

	logrus.Debugf("Found %d migration numbers %v", len(numbers), numbers)

	nextNum := calculatenextNum(numbers, maxLength)

	logrus.Debugf("Next migration number: %s", nextNum)

	return nextNum
}

func getFilesFromDir(dirPath string) []os.DirEntry {
	logrus.Debugf("entered getFilesFromDir function dirPath: %s", dirPath)

	logrus.Debugf("Reading migrations directory: %s", dirPath)

	files, err := os.ReadDir(dirPath)
	if err != nil {
		logrus.Fatalf("Failed to read migrations directory: %s err: %v", dirPath, err)
	}

	logrus.Debugf("Found %d files in the directory", len(files))

	return files
}

func extractnumbers(files []os.DirEntry) ([]int, int) {
	logrus.Debugf("entered extractnumbers function files: %v", files)

	re := regexp.MustCompile(`^(\d+)_.+\.up.sql$`)
	numbers := make([]int, 0)
	maxLength := 0

	logrus.Debugf("Extracting migration numbers from %d files %v", len(files), files)

	for _, file := range files {
		logrus.Debugf("Extracting migration number from file: %s", file.Name())

		match := re.FindStringSubmatch(file.Name())
		if match != nil {
			num, err := strconv.Atoi(match[1])
			if err != nil {
				logrus.Fatalf("Failed to parse migration number: %s err: %v", file.Name(), err)
			}

			logrus.Debugf("Found migration number: %d", num)

			numbers = append(numbers, num)

			if len(match[1]) > maxLength {
				maxLength = len(match[1])
			}
		}
	}

	logrus.Debugf("Found %d migration numbers %v", len(numbers), numbers)

	return numbers, maxLength
}

func calculatenextNum(numbers []int, maxLength int) string {
	logrus.Debugf(
		"entered calculatenextNum function numbers: %v maxLength: %d",
		numbers, maxLength,
	)

	if len(numbers) == 0 {
		logrus.Debugf("No valid migration numbers found, defaulting to %s", firstNumber)

		return firstNumber
	}

	sort.Ints(numbers)

	logrus.Debugf("Sorted migration numbers: %v", numbers)

	logrus.Debugf("Checking if migration numbers are consecutive")

	for i, num := range numbers {
		if i+1 != num {
			logrus.Fatalf("missing migration number: %d", i+1)
		}
	}

	nextNumber := numbers[len(numbers)-1] + 1
	logrus.Debugf("Next migration number: %d", nextNumber)

	formatString := fmt.Sprintf("%%0%dd", maxLength)
	nextNumberStr := fmt.Sprintf(formatString, nextNumber)
	logrus.Debugf("Next migration number with format: %s", nextNumberStr)

	return nextNumberStr
}
